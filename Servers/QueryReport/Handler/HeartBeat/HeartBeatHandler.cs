using GameSpyLib.Logging;
using QueryReport.DatabaseQuery;
using QueryReport.Structure;
using System;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Reflection;
using System.Text;
using QueryReport.Server;
using MaxMind.GeoIP2;

namespace QueryReport.Handler.HeartBeat
{
    public class HeartBeatHandler
    {
        byte[] testqr = { 0x3, 0xe6, 0x79, 0x72, 0xc6, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x69, 0x70, 0x30, 0x0, 0x31, 0x39, 0x32, 0x2e, 0x31, 0x36, 0x38, 0x2e, 0x31, 0x2e, 0x31, 0x30, 0x32, 0x0, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x70, 0x6f, 0x72, 0x74, 0x0, 0x31, 0x31, 0x31, 0x31, 0x31, 0x0, 0x6e, 0x61, 0x74, 0x6e, 0x65, 0x67, 0x0, 0x31, 0x0, 0x73, 0x74, 0x61, 0x74, 0x65, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x64, 0x0, 0x33, 0x0, 0x67, 0x61, 0x6d, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x0, 0x67, 0x6d, 0x74, 0x65, 0x73, 0x74, 0x0, 0x68, 0x6f, 0x73, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x0, 0x47, 0x61, 0x6d, 0x65, 0x53, 0x70, 0x79, 0x20, 0x51, 0x52, 0x32, 0x20, 0x53, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x0, 0x67, 0x61, 0x6d, 0x65, 0x76, 0x65, 0x72, 0x0, 0x32, 0x2e, 0x30, 0x30, 0x0, 0x68, 0x6f, 0x73, 0x74, 0x70, 0x6f, 0x72, 0x74, 0x0, 0x32, 0x35, 0x30, 0x30, 0x30, 0x0, 0x6d, 0x61, 0x70, 0x6e, 0x61, 0x6d, 0x65, 0x0, 0x67, 0x6d, 0x74, 0x6d, 0x61, 0x70, 0x31, 0x0, 0x67, 0x61, 0x6d, 0x65, 0x74, 0x79, 0x70, 0x65, 0x0, 0x61, 0x72, 0x65, 0x6e, 0x61, 0x0, 0x6e, 0x75, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x0, 0x33, 0x0, 0x6e, 0x75, 0x6d, 0x74, 0x65, 0x61, 0x6d, 0x73, 0x0, 0x32, 0x0, 0x6d, 0x61, 0x78, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x73, 0x0, 0x33, 0x32, 0x0, 0x67, 0x61, 0x6d, 0x65, 0x6d, 0x6f, 0x64, 0x65, 0x0, 0x6f, 0x70, 0x65, 0x6e, 0x70, 0x6c, 0x61, 0x79, 0x69, 0x6e, 0x67, 0x0, 0x74, 0x65, 0x61, 0x6d, 0x70, 0x6c, 0x61, 0x79, 0x0, 0x31, 0x0, 0x66, 0x72, 0x61, 0x67, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x0, 0x30, 0x0, 0x74, 0x69, 0x6d, 0x65, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x0, 0x34, 0x30, 0x0, 0x67, 0x72, 0x61, 0x76, 0x69, 0x74, 0x79, 0x0, 0x38, 0x30, 0x30, 0x0, 0x72, 0x61, 0x6e, 0x6b, 0x69, 0x6e, 0x67, 0x6f, 0x6e, 0x0, 0x31, 0x0, 0x0, 0x0, 0x3, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x5f, 0x0, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x5f, 0x0, 0x64, 0x65, 0x61, 0x74, 0x68, 0x73, 0x5f, 0x0, 0x70, 0x69, 0x6e, 0x67, 0x5f, 0x0, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x0, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x0, 0x0, 0x4a, 0x6f, 0x65, 0x20, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x0, 0x32, 0x39, 0x0, 0x32, 0x33, 0x0, 0x33, 0x33, 0x31, 0x0, 0x30, 0x0, 0x35, 0x35, 0x39, 0x0, 0x4c, 0x33, 0x33, 0x74, 0x20, 0x30, 0x6e, 0x33, 0x0, 0x39, 0x0, 0x31, 0x39, 0x0, 0x34, 0x31, 0x32, 0x0, 0x31, 0x0, 0x38, 0x35, 0x0, 0x52, 0x61, 0x70, 0x74, 0x6f, 0x72, 0x0, 0x31, 0x34, 0x0, 0x32, 0x34, 0x0, 0x33, 0x31, 0x37, 0x0, 0x30, 0x0, 0x34, 0x31, 0x33, 0x0, 0x0, 0x2, 0x74, 0x65, 0x61, 0x6d, 0x5f, 0x74, 0x0, 0x73, 0x63, 0x6f, 0x72, 0x65, 0x5f, 0x74, 0x0, 0x61, 0x76, 0x67, 0x70, 0x69, 0x6e, 0x67, 0x5f, 0x74, 0x0, 0x0, 0x52, 0x65, 0x64, 0x0, 0x34, 0x33, 0x36, 0x0, 0x31, 0x30, 0x38, 0x0, 0x42, 0x6c, 0x75, 0x65, 0x0, 0x39, 0x38, 0x0, 0x34, 0x35, 0x0};
        /// Client or server information come in
        /// </summary>
        /// <param name="server"></param>
        /// <param name="packet"></param>
        public static void HeartbeatResponse(QRServer server, EndPoint endPoint, byte[] buffer)
        {

            byte[] recvKeys = new byte[4];
            //we copy 4 bytes information prepare for reply 
            Array.Copy(buffer, 1, recvKeys, 0, 4);

            byte[] restData = buffer.Skip(5).ToArray();
            string recvData = Encoding.UTF8.GetString(restData);
            string[] dataFrag;
            string serverData, playerData, teamData;
            if (IsServerDataValid(recvData, out dataFrag))
            {
                serverData = dataFrag[0];
                playerData = dataFrag[1];
                teamData = dataFrag[2];
            }
            else
            {
                //we revieved a wrong data, we have to send challege to game server
                byte[] sendingBuffer = GenerateChallenge(recvKeys);

                server.SendAsync(endPoint, sendingBuffer);
                string errorMsg = string.Format("[HeartBeat] Invalid Server Data Received From {0}:{1}-{2}", server.Endpoint.Address, server.Endpoint.Port, dataFrag[0]);
                server.ToLog(errorMsg);
                return;
            }
            // We only care about the server data
            string[] serverDataFrag = serverData.Split(new string[] { "\x00" }, StringSplitOptions.None);
            //server.ToLog(LogLevel.Debug, string.Format("[QR] [HeartBeat] Data received From {0}", server.Socket.RemoteEndPoint.ToString()));
            server.ToLog(LogLevel.Debug, string.Format("[QR] [HeartBeat] server info:{0} \t player info:{1} \t team info:{2}", serverData, playerData, teamData));

            GameServerData gameServer = new GameServerData(server.Endpoint);
            // set the country based off ip address if its IPv4

            //we set the server variables
            SetServerVariables(gameServer, serverDataFrag, server.Endpoint);

            LogWriter.Log.Write("[QR] No impliment function for Heartbeatpacket!", LogLevel.Debug);
            //TODO
        }

        private static void SetServerVariables(GameServerData gameServer, string[] serverDataFrag, IPEndPoint remote)
        {
            //gameServer.Country = (remote.Address.AddressFamily == AddressFamily.InterNetwork)
            //   ? GeoIP.GetCountryCode(remote.Address).ToUpperInvariant()
            //   : "??";

            using (var reader = new DatabaseReader("./GeoLite2-Country.mmdb"))
            {
                var response = reader.Country("128.101.101.101");
                var country = response.Country;
                Console.WriteLine(country.IsoCode);            // 'US'
                Console.WriteLine(country.Name);               // 'United States'
                Console.WriteLine(country.Names["zh-CN"]);     // '美国'
                Console.WriteLine(country.Confidence);         // 99
            }

            for (int i = 0; i < serverDataFrag.Length - 1; i += 2)
            {
                //Fetch the properties
                PropertyInfo property = typeof(GameServerData).GetProperty(serverDataFrag[i]);
                if (property == null)
                    continue;

            }
        }

        private static bool IsServerDataValid(string recvData, out string[] dataFrag)
        {
            dataFrag = recvData.Split(new string[] { "\x00\x00\x00", "\x00\x00\x02" }, StringSplitOptions.None);
            if (dataFrag.Length != 3 && !recvData.EndsWith("\x00\x00"))
            {
                // server data is not valid so we ignore
                return false;
            }
            else
            {
                return true;
            }
        }
        private static byte[] GenerateChallenge(byte[] recvKeys)
        {
            byte[] sendingbuffer = new byte[23];
            sendingbuffer[0] = QR.QRMagic1;
            sendingbuffer[1] = QR.QRMagic2;
            sendingbuffer[2] = QRGameServer.Challenge;
            Array.Copy(recvKeys, 0, sendingbuffer, 3, 4);
            //TODO hard coded challenge, we will make it dynamic later
            byte[] challenge = {0x44, 0x3d, 0x73,0x7e, 0x6a, 0x59, 0x30, 0x30, 0x37, 0x43, 0x39, 0x35, 0x41, 0x42, 0x42, 0x35, 0x37, 0x34,
                                                0x43, 0x43, 0x00};
            Array.Copy(challenge, 0, sendingbuffer, 7, challenge.Length);
            return sendingbuffer;
        }
        private static void SaveQRinfo(byte[] buffer)
        {
            string savestr = "";

            foreach (byte b in buffer)
            {
                savestr += @"0x" + Convert.ToString(b, 16) + " ,";
            }
            server.ToLog(savestr);
            //byte[] serverData = new byte[buffer.Length - 5];


            //string temp = Encoding.ASCII.GetString(serverData );
            //string temp1 = temp.Substring(3, temp.Length-1);

            //string[] temp2 = temp1.TrimStart('\0').Split('\0');
        }
    }
}
